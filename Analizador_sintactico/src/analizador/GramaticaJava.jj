options {
  IGNORE_CASE = true;
  STATIC = false;
}

PARSER_BEGIN(JavaScriptLexer)
/** Analizador de un subconjunto del lenguaje JavaScript. */
package analizador;

public class JavaScriptLexer {
  public static void main(String[] args) throws ParseException {
    JavaScriptLexer lexer = new JavaScriptLexer(System.in);
    lexer.Program();
  }
}
PARSER_END(JavaScriptLexer)

/** Espacios en blanco y comentarios */
SKIP : {
    " " 
    | "\t" 
    | "\r" 
    | "\n"
    | < "/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/" > // Comentarios multilínea
    | < "//" (~["\r", "\n"])* ("\r" | "\n") > // Comentarios de una línea
}

/** Tokens */
TOKEN : {
    //Palabras reservadas
    < AWAIT: "await" >
  | < BREAK: "break" >
  | < CASE: "case" >
  | < CATCH: "catch" >
  | < CLASS: "class" >
  | < CONSOLE: "console" >
  | < CONST: "const" >
  | < CONTINUE: "continue" >
  | < DEBUGGER: "debugger" >
  //| < DEFAULT: "default" >
  | < DELETE: "delete" >
  | < DO: "do" >
  | < ELSE: "else" >
  | < ENUM: "enum" >
  | < EXPORT: "export" >
  | < EXTENDS: "extends" >
  | < FALSE: "false" >
  | < FINALLY: "finally" >
  | < FOR: "for" >
  | < FUNCTION: "function" >
  | < IF: "if" >
  | < IMPLEMENTS: "implements" >
  | < IMPORT: "import" >
  | < IN: "in" >
  | < INSTANCEOF: "instanceof" >
  | < INTERFACE: "interface" >
  | < LET: "let" >
  | < LOG: "log" >
  | < NEW: "new" >
  | < NULL: "null" >
  | < PACKAGE: "package" >
  | < PRIVATE: "private" >
  | < PROTECTED: "protected" >
  | < PUBLIC: "public" >
  | < RETURN: "return" >
  | < SUPER: "super" >
  | < SWITCH: "switch" >
  | < STATIC: "static" >
  | < THIS: "this" >
  | < THROW: "throw" >
  | < TRY: "try" >
  | < TYPEOF: "typeof" >
  | < TRUE: "true" >
  | < VAR: "var" >
  | < VOID: "void" >
  | < WHILE: "while" >
  | < WITH: "with" >
  | < YIELD: "yield" >

    //Tokens generales como, identificadores, enteros, flotantes y cadenas.
  | < IDENTIFICADOR: (["a"-"z", "A"-"Z", "_"]) (["a"-"z", "A"-"Z", "0"-"9", "_"])* >
  | < INT: (["0"-"9"])+ >
  | < FLOAT: (["0"-"9"])+ "." (["0"-"9"])* >
  | < STRING: "\"" (~["\""])* "\"" >

  | < I_PARENTESIS: "(" >
  | < D_PARENTESIS: ")" >
  | < LLAVE_IZQ: "{" >
  | < LLAVE_DER: "}" >
  | < CORCHETE_IZQ: "[" >
  | < CORCHETE_DER: "]" >
  | < PUNTO_Y_COMA: ";" >
  | < COMA: "," >
  | < PUNTO: "." >

  | < MAS: "+" >
  | < MENOS: "-" >
  | < MULT: "*" >
  | < DIV: "/" >
  | < MOD: "%" >
  | < IGUAL: "=" >
  | < EQ: "==" >
  | < NEQ: "!=" >
  | < LT: "<" >
  | < GT: ">" >
  | < LTE: "<=" >
  | < GTE: ">=" >
}

/** Reglas de producción */
void Program() :
{}
{
  (Statement())* //<PUNTO_Y_COMA>
}

void Statement() :
{}
{
    Block()
  | VariableDeclaration()
  | IfStatement()
  | WhileStatement()
  | ForStatement()
  | ReturnStatement()
  | ExpressionStatement()
}

void Block() :
{}
{
  <LLAVE_IZQ> (Statement())* <LLAVE_DER>
}

void VariableDeclaration() :
{}
{
  (<VAR> | <LET> | <CONST>) <IDENTIFICADOR> ( <IGUAL> Expression() )? <PUNTO_Y_COMA>
}

void IfStatement() :
{}
{
  <IF> <I_PARENTESIS> Expression() <D_PARENTESIS> Statement() ( <ELSE> Statement() )?
}

void WhileStatement() :
{}
{
  <WHILE> <I_PARENTESIS> Expression() <D_PARENTESIS> Statement()
}

void ForStatement() :
{}
{
  <FOR> <I_PARENTESIS> ( VariableDeclaration() | [Expression()] <PUNTO_Y_COMA> ) [Expression()] <PUNTO_Y_COMA> [Expression()] <D_PARENTESIS> Statement()
}

void ReturnStatement() :
{}
{
  <RETURN> [Expression()] <PUNTO_Y_COMA>
}

void ExpressionStatement() :
{}
{
  Expression() <PUNTO_Y_COMA>
}

void Expression() :
{}
{
  AssignmentExpression()
}

void AssignmentExpression() :
{}
{
  ConditionalExpression() ( <IGUAL> AssignmentExpression() )?
}

void ConditionalExpression() :
{}
{
  OrExpression()
}

void OrExpression() :
{}
{
  AndExpression() ( "||" AndExpression() )*
}

void AndExpression() :
{}
{
  EqualityExpression() ( "&&" EqualityExpression() )*
}

void EqualityExpression() :
{}
{
  RelationalExpression() ( ( <EQ> | <NEQ> ) RelationalExpression() )*
}

void RelationalExpression() :
{}
{
  AdditiveExpression() ( ( <LT> | <GT> | <LTE> | <GTE> ) AdditiveExpression() )*
}

void AdditiveExpression() :
{}
{
  MultiplicativeExpression() ( ( <MAS> | <MENOS> ) MultiplicativeExpression() )*
}

void MultiplicativeExpression() :
{}
{
  UnaryExpression() ( ( <MULT> | <DIV> | <MOD> ) UnaryExpression() )*
}

void UnaryExpression() :
{}
{
    <MAS> UnaryExpression()
  | <MENOS> UnaryExpression()
  | PrimaryExpression()
}

void PrimaryExpression() :
{}
{
    <IDENTIFICADOR>
  | <INT>
  | <FLOAT>
  | <STRING>
  | <I_PARENTESIS> Expression() <D_PARENTESIS>
}
