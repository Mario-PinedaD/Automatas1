options {
  IGNORE_CASE = true;
  STATIC = false;
}

PARSER_BEGIN(JavaScriptLexer)
/** Analizador de un subconjunto del lenguaje JavaScript. */
package analizador;

public class JavaScriptLexer {
  public static void main(String[] args) throws ParseException {
    JavaScriptLexer lexer = new JavaScriptLexer(System.in);
    lexer.Program();
  }
}
PARSER_END(JavaScriptLexer)

/** Espacios en blanco y comentarios */
SKIP : {
    " " 
    | "\t" 
    | "\r" 
    | "\n"
    | < "/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/" > // Comentarios multilínea
    | < "//" (~["\r", "\n"])* ("\r" | "\n") > // Comentarios de una línea
}

/** Tokens */
TOKEN : {
    //Palabras reservadas
    < AWAIT: "await" >
  | < BREAK: "break" >
  | < CASE: "case" >
  | < CATCH: "catch" >
  | < CLASS: "class" >
  | < CONSOLE: "console" >
  | < CONST: "const" >
  | < CONTINUE: "continue" >
  | < DEBUGGER: "debugger" >
  //| < DEFAULT: "default" >
  | < DELETE: "delete" >
  | < DO: "do" >
  | < ELSE: "else" >
  | < ENUM: "enum" >
  | < EXPORT: "export" >
  | < EXTENDS: "extends" >
  | < FALSE: "false" >
  | < FINALLY: "finally" >
  | < FOR: "for" >
  | < FUNCTION: "function" >
  | < IF: "if" >
  | < IMPLEMENTS: "implements" >
  | < IMPORT: "import" >
  | < IN: "in" >
  | < INSTANCEOF: "instanceof" >
  | < INTERFACE: "interface" >
  | < LET: "let" >
  | < LOG: "log" >
  | < NEW: "new" >
  | < NULL: "null" >
  | < PACKAGE: "package" >
  | < PRIVATE: "private" >
  | < PROTECTED: "protected" >
  | < PUBLIC: "public" >
  | < RETURN: "return" >
  | < SUPER: "super" >
  | < SWITCH: "switch" >
  | < STATIC: "static" >
  | < THIS: "this" >
  | < THROW: "throw" >
  | < TRY: "try" >
  | < TYPEOF: "typeof" >
  | < TRUE: "true" >
  | < VAR: "var" >
  | < VOID: "void" >
  | < WHILE: "while" >
  | < WITH: "with" >
  | < YIELD: "yield" >

    //Tokens generales como, identificadores, enteros, flotantes y cadenas.
  | < IDENTIFICADOR: (["a"-"z", "A"-"Z", "_"]) (["a"-"z", "A"-"Z", "0"-"9", "_"])* >
  | < INT: (["0"-"9"])+ >
  | < FLOAT: (["0"-"9"])+ "." (["0"-"9"])* >
  | < STRING: "\"" (~["\""])* "\"" >

  | < PARENTESIS_I: "(" >
  | < PARENTESIS_D: ")" >
  | < LLAVE_IZQ: "{" >
  | < LLAVE_DER: "}" >
  | < CORCHETE_IZQ: "[" >
  | < CORCHETE_DER: "]" >
  | < PUNTO_Y_COMA: ";" > {System.out.println("PUNTO_Y_COMA -> " + image + "\n"); }
  | < COMA: "," >
  | < PUNTO: "." >

  | < MAS: "+" >
  | < MENOS: "-" >
  | < MULT: "*" >
  | < DIV: "/" >
  | < MOD: "%" >
  | < IGUAL: "=" >
  | < EQ: "==" >
  | < NEQ: "!=" >
  | < LT: "<" >
  | < GT: ">" >
  | < LTE: "<=" >
  | < GTE: ">=" >
}

/** Reglas de producción */
void Program() :
{}
{
  (Statement())* <PUNTO_Y_COMA>
}

void Statement() :{} {
    Block()
  | VariableDeclaration()
  | IfStatement()
  | WhileStatement()
  | ForStatement()
  | ReturnStatement()
  | ExpressionStatement()
  | FunctionDeclare()
  | ConsoleStatement()
}

void FunctionDeclare() : {} {
  <FUNCTION> <IDENTIFICADOR> <PARENTESIS_I> (ParameterList())? <PARENTESIS_D> Block() <PUNTO_Y_COMA>
}

void ParameterList() : {} {
  <IDENTIFICADOR> (<COMA> <IDENTIFICADOR>)*
}

void Block() : {} {
  <LLAVE_IZQ> (Statement())* <LLAVE_DER>
}

void VariableDeclaration() : {} {
  (<VAR> | <LET> | <CONST>) <IDENTIFICADOR> ( <IGUAL> Expression() )? <PUNTO_Y_COMA>
}

void IfStatement() : {} {
  <IF> <PARENTESIS_I> Expression() <PARENTESIS_D> Statement() ( <ELSE> Statement() )?
}

void WhileStatement() : {} {
  <WHILE> <PARENTESIS_I> Expression() <PARENTESIS_D> Statement()
}

void ForStatement() : {} {
  <FOR> <PARENTESIS_I> ( VariableDeclaration() | [Expression()] <PUNTO_Y_COMA> ) [Expression()] <PUNTO_Y_COMA> [Expression()] <PARENTESIS_D> Statement()
}

void ReturnStatement() : {} {
    <RETURN> [Expression()] <PUNTO_Y_COMA> 
}

//Pa que chambee el console.log
void ConsoleStatement() : {} {
    <CONSOLE> <PUNTO> <LOG> <PARENTESIS_I> Contenido() <PARENTESIS_D> <PUNTO_Y_COMA>
}


//El contenido del console.log
void Contenido() : {} { 
    (DatosBasicos() | Concatenation())*
}

void Concatenation() : {} {
    (<COMA> DatosBasicos()) | ( <MAS> DatosBasicos() )
}
void ExpressionStatement() : {} {
  Expression() <PUNTO_Y_COMA>
}

void Expression() : {} {
  AssignmentExpression()
}

void AssignmentExpression() : {} {
  ConditionalExpression() ( <IGUAL> AssignmentExpression() )?
}

void ConditionalExpression() : {} {
  OrExpression()
}

void OrExpression() : {} {
  AndExpression() ( "||" AndExpression() )*
}

void AndExpression() : {} {
  EqualityExpression() ( "&&" EqualityExpression() )*
}

void EqualityExpression() : {} {
  RelationalExpression() ( ( <EQ> | <NEQ> ) RelationalExpression() )*
}

void RelationalExpression() : {} {
  AdditiveExpression() ( ( <LT> | <GT> | <LTE> | <GTE> ) AdditiveExpression() )*
}

void AdditiveExpression() : {} {
  MultiplicativeExpression() ( ( <MAS> | <MENOS> ) MultiplicativeExpression() )*
}

void MultiplicativeExpression() : {} {
  UnaryExpression() ( ( <MULT> | <DIV> | <MOD> ) UnaryExpression() )*
}

void UnaryExpression() : {} {
    <MAS> UnaryExpression()
  | <MENOS> UnaryExpression()
  | PrimaryExpression()
}

void PrimaryExpression() : {} {
    <IDENTIFICADOR>
  | <INT>
  | <FLOAT>
  | <STRING>
  | <PARENTESIS_I> Expression() <PARENTESIS_D>
}

//Falta checar bien lo de For

void DatosBasicos() : {} {
    <INT> | <IDENTIFICADOR> | <FLOAT> | <STRING> 
}

void ForBucle() : {} {
    <FOR> <PARENTESIS_I> ContenidoFor() <PARENTESIS_D> Block() <PUNTO_Y_COMA>
}